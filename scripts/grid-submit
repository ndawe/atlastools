#!/usr/bin/env python

from argparse import ArgumentParser

parser = ArgumentParser(usage="%(prog)s [args] samplename1 samplename2 ...")
parser.add_argument('-m',"--meta", type=str, dest="metadata",
                  help="", default="datasets.yml")
parser.add_argument('-v', "--version", type=int, dest="version",
                  help="version number appended to output dataset name", default=1)
parser.add_argument("--extFile", type=str, dest="extfile",
                  help="extra files to send to worker nodes", default=None)
parser.add_argument('-s',"--student", type=str, dest="student",
                  help="the file (excluding .py extension) containing a class of the same name inheriting from rootpy.batch.Student", required=True)
parser.add_argument('-u',"--user", type=str, dest="user",
                  help="your grid dataset username i.e. JohnDoe", required=True)
parser.add_argument("--nosite", action='store_true',
                  help="override site in metadata and let the grid decide")
parser.add_argument('-g', "--get", action='store_true',
                  help="download datasets")
parser.add_argument('-d', '--dest', type=str, default='.', help="directory in which to download the datasets")
parser.add_argument('datasets', type=str, nargs="+")
args, user_args = parser.parse_known_args()

import yaml
import sys
from subprocess import call
import fnmatch
import os
from glob import glob

metafile = open(args.metadata)
metadata = yaml.load(metafile)
metafile.close()

sorted_datasets = sorted(metadata.keys())

# expand globs
datasets = []
for dataset in args.datasets:
    if '*' in dataset:
        datasets += fnmatch.filter(sorted_datasets, dataset)
    else:
        datasets.append(dataset)

exclude_files = []
extra_files = []
if os.path.isfile('.pandaconfig'):
    with open('.pandaconfig') as f:
        for i, line in enumerate(f.readlines()):
            try:
                op, path = line.strip().split()
            except:
                sys.exit(".pandaconfig: '%s' not understood on line %i" % i)
            if op == 'include':
                extra_files += glob(path)
            elif op == 'exclude':
                exclude_files += glob(path)
            else:
                sys.exit(".pandaconfig: operation '%s' not understood on line %i" % i)

for dataset in datasets:
    if not dataset in metadata:
        sys.exit("dataset %s not defined in metadata %s" % (dataset, args.metadata))
    panda_outDS = "user.%s.%s.%s.v%i" % (args.user, args.student, dataset, args.version)
    if args.get:
        if not os.path.isdir(args.dest):
            sys.exit("destination path %s does not exist" % args.dest)
        call("cd %s; run -e grid dq2-get -T 3,8 %s/; cd -" % (args.dest, panda_outDS), shell=True)
        continue
    inDS = metadata[dataset]["container"]
    if type(inDS) is not list:
        inDS = [inDS]
    for panda_inDS in inDS:
        panda_site = None
        if ':' in panda_inDS:
            panda_inDS, panda_site = panda_inDS.split(':') 
        panda_bexec = "./setup.sh build"
        panda_exec = "source setup.sh worker; grid-batch --dataset %s --metadata %s --student %s %%IN" % (dataset, args.metadata, args.student)
        panda_outputs = "%s.root,cutflow.p" % dataset 
        if not args.extfile is None:
            panda_extFiles = ",".join([panda_extFiles, args.extfile])
        panda_opts = []
        if exclude_files:
            panda_opts.append("--excludeFile %s" % ','.join(exclude_files))
        if extra_files:
            panda_opts.append("--extFile %s" % ','.join(extra_files))
        command = [
            "prun",
            "--bexec \"%s\"" % panda_bexec,
            "--exec \"%s\"" % panda_exec,
            "--inDS %s" % panda_inDS,
            "--outDS %s" % panda_outDS,
            "--outputs %s" % panda_outputs
        ] + panda_opts
        if panda_site is not None and "--site" not in user_args and not args.nosite:
            command.append("--site %s" % panda_site)
        command = " ".join(command)
        if user_args:
            command += " %s" % ' '.join(user_args)
        print "executing:"
        print command
        call(command, shell=True)
